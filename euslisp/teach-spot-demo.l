(ros::roseus-add-msgs "speech_recognition_msgs")
(ros::roseus-add-msgs "geometry_msgs")
(ros::roseus-add-msgs "follow_waypoints")
;; (load "package://hand_navigation_pr2/euslisp/give-hand-pose.l")
(load "package://hand_navigation_pr2/euslisp/marker.l")
(ros::roseus "teach_spot")
(setq robot-type (ros::get-param "~robot"))
(when (string= robot-type "pr2")
  (load "package://pr2eus/pr2-interface.l")
  (pr2-init nil))
(when (string= robot-type "fetch")
  (load "package://fetcheus/fetch-interface.l")
  (fetch-init nil))

(defun my-string-left-trim (bag str)
  (declare (string str))
  (declare (string bag))
  (if (string= (subseq str 0 (length bag)) bag)
      (subseq str (length bag))
      nil))

(defun my-string-right-trim (bag str)
  (declare (string str))
  (declare (string bag))
  (if (string= (subseq str (- (length str) (length bag))) bag)
      (subseq str 0 (- (length str) (length bag)))
      nil))

(defun counter-clockwise-angle-between-vectors (v1 v2 normal-vector)
  (let* ((det (v. normal-vector (v* v1 v2)))
         (dot (v. v1 v2))
         (angle (+ (atan2 (- det) (- dot)) pi)))
    (when (eps= angle 2pi)
      (setq angle 0.0))
    angle))

(defun coords-difference (a b)
  (/ (norm (send (send a :transformation b) :pos)) 1000))

;; (defun cross-line (a b c d)
;;   (let ((x1 (elt a 0)) (x2 (elt b 0)) (x3 (elt c 0)) (x4 (elt d 0))
;;         (y1 (elt a 1)) (y2 (elt b 1)) (y3 (elt c 1)) (y4 (elt d 1)))
;;     (setq m (- (* (- x1 x2) (- y3 y1)) (* (- y1 y2) (- x3 x1))))
;;     (setq n (- (* (- x1 x2) (- y4 y1)) (* (- y1 y2) (- x4 x1))))
;;     (when (> (* m n) 0)
;;       (return-from cross-line nil))
    
;;     (setq det (- (* (- x1 x2) (- y4 y3)) (* (- x4 x3) (- y1 y2))))
;;     (setq u (/ (+ (* (- y4 y3) (- x4 x2)) (* (- x3 x4) (- y4 y2))) det))
;;     (setq x (+ (* u x1) (* (- 1 u) x2)))
;;     (setq y (+ (* u y1) (* (- 1 u) y2))))
;;     (cons x y)
;;     ))

(defclass teach-spot
    :slots (label mode spot-msg spot-graph spot-list path prev-n goal-n goal-name sol))

(defmethod teach-spot
    (:init ()
     (setq label 0)
     (setq mode :record)
     (setq spot-graph (instance graph :init))
     (setq sol (instance breadth-first-graph-search-solver :init))
     (setq client (instance ros::simple-action-client :init "waypoints_action" follow_waypoints::WaypointsAction))
     ;; (send client :wait-for-server)
     (ros::subscribe "/Tablet/voice_roman" speech_recognition_msgs::SpeechRecognitionCandidates #'send self :voice-cb)
     (ros::subscribe "/amcl_pose" geometry_msgs::posewithcovariancestamped #'send self :spot-cb)
     (ros::advertise "/follow_waypoints/initialpose" geometry_msgs::posewithcovariancestamped 1)
     (ros::advertise "/path_reset" std_msgs::empty 1)
     (ros::advertise "/path_ready" std_msgs::empty 1)
     (ros::ros-info "init ended"))

  (:nodes ()
          (send spot-graph :nodes))

  (:spot-list ()
              spot-list)

  (:graph ()
          spot-graph)

  (:path ()
         path)

  (:feedback-cb (msg)
                (ros::ros-info (format nil "[feedback]~A" (send (send msg :feedback) :text))))

  (:spot-cb (msg)
            (if msg
                (setq spot-msg (ros::tf-pose->coords (send msg :pose :pose)))))

  ;; (:check-cross-line (u v)
  ;;                    (dolist (n (send spot-graph :nodes))
  ;;                      (let ((arc-list (send n :arc-list)))
  ;;                        (dolist (ar arc-list)
  ;;                          (let ((a (list (elt (send (send u :get :coords) :pos) 0)
  ;;                                         (elt (send (send u :get :coords) :pos) 1)))
  ;;                                (b (list (elt (send (send v :get :coords) :pos) 0)
  ;;                                         (elt (send (send v :get :coords) :pos) 1)))
  ;;                                (c (list (elt (send (send n :get :coords) :pos) 0)
  ;;                                         (elt (send (send n :get :coords) :pos) 1)))
  ;;                                (d (list (elt (send (send (send ar :to) :get :coords) :pos) 0)
  ;;                                         (elt (send (send (send ar :to) :get :coords) :pos) 1))))
  ;;                            (setq ret (cross-line a b c d))
  ;;                            (when ret
  ;;                              (setq new (instance node :init (format nil "~A" label)))
  ;;                              (incf label)
  ;;                              (send spot-graph :add-node new)
  ;;                              (send spot-graph :add-arc-from-to u new :both t)
  ;;                              (send spot-graph :add-arc-from-to v new :both t)
  ;;                              (send spot-graph :add-arc-from-to n new :both t)
  ;;                              (send spot-graph :add-arc-from-to (send ar :to) new :both t)
  ;;                              (send u :unlink v)
  ;;                              (send v :unlink u)
  ;;                              (send (send ar :to) :unlink n)))))))
                               
  (:add-spot (spot-coords &optional name)
             (when (null spot-coords)
               (return-from :add-spot))
             (dolist (i (set-difference (send spot-graph :nodes)
                                        (if (null prev-n)
                                            nil
                                            (mapcar #'(lambda (n) (cadr n)) (send prev-n :successors)))))
               (unless (string= (send i :name) (send prev-n :name))
                 (let ((diff (abs (coords-difference spot-coords (send i :get :coords)))))
                   (when  (< diff 0.40)
                     (unless (and (send i :get :name-jp) name)
                       (ros::ros-info "diff: ~A" diff)
                       (when prev-n
                         (send spot-graph :add-arc-from-to prev-n i :both t)
                         (ros::ros-info "arc from ~A to ~A" (send prev-n :name) (send i :name)))
                       (when name
                         (ros::ros-info "rename ~A to ~A" (send i :name) (car name)) ;;rename
                         (send i :name (car name))
                         (send i :put :name-jp (cadr name)))
                       ;; (send self :check-cross-line prev-n i)
                       (setq prev-n i)
                       (return-from :add-spot))))))

             (let (n)
               (setq n (instance node :init (or (if name (car name) nil)
                                                (format nil "~A" label))))
               (if name
                   (send n :put :name-jp (cadr name))
                   (incf label))
               (send n :put :coords spot-coords)
               (ros::ros-info "node ~A ~% coords:~A" (send n :name) (send n :get :coords))
               (send spot-graph :add-node n)

               (when prev-n
                 (send spot-graph :add-arc-from-to prev-n n :both t)
                 ;; (send self :check-cross-line prev-n n)
                 (ros::ros-info "arc from ~A to ~A" (send prev-n :name) (send n :name)))
               (setq prev-n n)
               ))

  (:output-graph ()
              ;; (send *ri* :speak-jp "グラフを出力します")
              (ros::ros-info "graph")
              (send spot-graph :write-to-file (format nil "~A" (send (ros::time-now) :to-nsec) path "output" "jpg")))

  (:voice-cb (msg)
             (let ((text (elt (send msg :transcript) 0))
                   (roman-text (elt (send msg :transcript) 1))
                   (seq-count 0))
               (ros::ros-info "text:~A" text)

               (cond
                 ((substringp "リセット" text)
                  (setq spot-graph (instance graph :init))
                  (setq prev-n nil)
                  (setq spot-list nil))

                 ((substringp "に行こう" text)
                  (setq goal-name (my-string-right-trim "niikou" roman-text))
                  (setq goal-n (send spot-graph :node goal-name))
                  (ros::ros-info "goal-node: ~A" (send goal-n :name))
                  (when goal-n
                    (let ((spot-coords spot-msg) start-n)
                      ;; (dolist (n (send spot-graph :nodes)) ;; if node exists nearby
                      ;;   (when (< (abs (coords-difference spot-coords (send n :get :coords))) 0.3)
                      ;;     (setq start-n n)
                      ;;     (return)))
                      (setq start-n prev-n)
                      (ros::ros-info "start-node: ~A" start-n)
                      (ros::ros-info "path0:~A" (length path))
                      (when start-n
                        (setq path nil)
                        ;; (setq path (send sol :solve-by-name spot-graph (send start-n :name) goal-name))
                        (send spot-graph :start-state start-n)
                        (send spot-graph :goal-state goal-n)
                        (setq path (send sol :solve spot-graph))
                        (when path
                          (setq mode :navigation)
                          (ros::publish "/path_reset" (instance std_msgs::empty :init))
                          (ros::duration-sleep 0.5)
                          (dolist (i path)
                            (ros::ros-info "publish waypoint ~A" (send (send i :state) :name))
                            (ros::sleep)
                            (let ((pose (instance geometry_msgs::posewithcovariancestamped :init)))
                              (send (send pose :header) :frame_id "map")
                              (send (send pose :header) :stamp (ros::time-now))
                              (send (send pose :header) :seq seq-count)
                              (incf seq-count)
                              (send (send pose :pose) :pose (ros::coords->tf-pose (send (send i :state) :get :coords)))
                              (ros::publish "/follow_waypoints/initialpose" pose)
                              ))
                          (ros::duration-sleep 0.5)
                          (setq goal (instance follow_waypoints::WaypointsActionGoal :init))
                          (send client :send-goal goal :feedback-cb #'(lambda (msg) (ros::ros-info (format nil "[feedback]~A" (send (send msg :feedback) :text)))))
                          ;; ;; (ros::publish "/path_ready" (instance std_msgs::empty :init))
                          (send client :wait-for-result)
                          (ros::ros-info (format nil "[result]~A" (send (send client :get-result) :result)))

                          (if (eq (send (send client :get-result) :result) 4)
                              (progn
                                (setq prev-n goal-n)
                                (send *ri* :speak-jp (format nil "~Aに到着しました" goal-name)))
                              (progn
                                (send *ri* :speak-jp (format nil "失敗しました"))
                                (setq prev-n nil)))
                          (setq goal-n nil)
                          (setq mode :record)
                          (return-from :voice-cb)))))

                  (ros::ros-info "solver failed")
                  (send *ri* :speak-jp "道がわかりません")
                  )

                 ((substringp "の行き方を教えて" text)
                  (setq goal-name (my-string-right-trim "の行き方を教えて" text))
                  (setq goal-n (send spot-graph :node goal-name))
                  (ros::ros-info "goal-node: ~A" (send goal-n :name))
                  (when goal-n
                    (let ((spot-coords spot-msg) start-n)
                      (setq start-n prev-n)
                      (ros::ros-info "start-node: ~A" (send start-n :name))
                      (when start-n
                        (setq path nil)
                        (setq path (send sol :solve-by-name spot-graph (send start-n :name) goal-name))
                        (when path
                          (dolist (i path)
                            (ros::ros-info (format nil "~A" (send (send i :state) :name))))
                          ;; (send *ri* :speak-jp "の順に通ります" :wait t)
                          (return-from :voice-cb))))
                    (ros::ros-info "solver failed")))
                 
                 ((and (substringp "ここが" text) (substringp "だよ" text))
                  (let (spot-name (spot-coords spot-msg))
                    (setq spot-name (list (my-string-left-trim "kokoga" (my-string-right-trim "dayo" roman-text))
                                          (my-string-left-trim "ここが" (my-string-right-trim "だよ" text))))
                    (unless (null spot-coords)
                      (ros::ros-info "spot-name: ~A" (cadr spot-name))
                      (push (cadr spot-name) spot-list)
                      ;; (send *ri* :speak-jp "はい")
                      (unless (null prev-n)
                        (when (< (abs (coords-difference spot-coords (send prev-n :get :coords))) 0.25)
                          (unless (send prev-n :get :name-jp)
                            (ros::ros-info (format nil "rename ~A to ~A" (send prev-n :name) (car spot-name)))
                            (send prev-n :put :coords spot-coords)
                            (send prev-n :name (car spot-name))
                            (send prev-n :put :name-jp (cadr spot-name))
                            (return-from :voice-cb))))
                      (send self :add-spot spot-coords spot-name))
                    ))
                 
                 ((string-equal "どこに行けますか" text)
                  (unless (null spot-list)
                    (dolist (i spot-list)
                      (send *ri* :speak-jp (format nil "~A" i) :wait t))
                    (send *ri* :speak-jp "に行けます")))
                 
                 ((string-equal "グラフを出して" text) (send self :output-graph))
                 (t nil))))

  (:run ()
        (case mode          
          (:record
           (let ((spot-coords spot-msg))
             (unless (null spot-coords)
               (when (null prev-n)
                 (send self :add-spot spot-coords))
               (unless (null prev-n)
                 (setq prev-v (send (send prev-n :get :coords) :rotate-vector #f(1 0 0)))
                 (setq v (send spot-coords :rotate-vector #f(1 0 0)))
                 (setq angle (counter-clockwise-angle-between-vectors prev-v v #f(0 0 1)))
                 (when (or (and (and (> (rad2deg angle) 40) (< (rad2deg angle) 320)) (> (abs (coords-difference spot-coords (send prev-n :get :coords))) 0.3)) (> (abs (coords-difference spot-coords (send prev-n :get :coords))) 0.8))
                   (send self :add-spot spot-coords)))
               )))

          (:navigation
           ;; (ros::ros-info "navigation")
           ;; (while (length path)
           ;;   (let* ((next-sn (pop path)) (next-n (send next-sn :state)) (next (send next-n :get :coords)) (diff (convert-go-to-robot next)) (x (car diff)) (d (cadr diff)))
           ;;     (ros::ros-info "x:~A d:~A" x d)
           ;;     (send *ri* :go-pos-unsafe 0 0 d)
           ;;     (send *ri* :go-pos-unsafe x 0 0)))
           ;; ;; (send *ri* :speak-jp (format nil "~Aに到着しました" goal))
           ;; (setq prev-n goal-n)
           ;; (setq goal-n nil)
           ;; (setq mode :record)
           
           ))
        (let* (spots (stamp (ros::time-now)) (header (instance std_msgs::header :init :stamp stamp :frame_id "/map")))
          (dolist (i (send spot-graph :nodes))          
            (push (cons (send i :name) (send i :get :coords)) spots))
          (publish-pin-marker-array spots header)
          (publish-arcs-marker-array (send spot-graph :nodes) header))
          
        ))

(setq *ts* (instance teach-spot :init))
(ros::rate 20)
(do-until-key
 (ros::spin-once)
 (send *ts* :run)
 (ros::sleep))
